<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>User Guide · BinaryTraits.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">BinaryTraits.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Motivation</a></li><li class="is-active"><a class="tocitem" href>User Guide</a><ul class="internal"><li><a class="tocitem" href="#Defining-traits-1"><span>Defining traits</span></a></li><li><a class="tocitem" href="#Assigning-traits-to-types-1"><span>Assigning traits to types</span></a></li><li><a class="tocitem" href="#Specifying-interfaces-1"><span>Specifying interfaces</span></a></li><li><a class="tocitem" href="#Additional-step-for-framework-providers-1"><span>Additional step for framework providers</span></a></li><li><a class="tocitem" href="#Summary-1"><span>Summary</span></a></li></ul></li><li><a class="tocitem" href="../concepts/">Concepts</a></li><li><a class="tocitem" href="../reference/">Reference</a></li><li><a class="tocitem" href="../design/">Under the hood</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>User Guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>User Guide</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/tk3369/BinaryTraits.jl/blob/master/docs/src/guide.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Defining-traits-1"><a class="docs-heading-anchor" href="#Defining-traits-1">Defining traits</a><a class="docs-heading-anchor-permalink" href="#Defining-traits-1" title="Permalink"></a></h2><h3 id="The-@trait-macro-1"><a class="docs-heading-anchor" href="#The-@trait-macro-1">The @trait macro</a><a class="docs-heading-anchor-permalink" href="#The-@trait-macro-1" title="Permalink"></a></h3><p>You can define a new trait using the <code>@trait</code> macro. The syntax is described below:</p><pre><code class="language-julia">@trait &lt;Trait&gt; [as &lt;Category&gt;] [prefix &lt;Can&gt;,&lt;Cannot&gt;] [with &lt;Trait1&gt;,&lt;Trait2&gt;,...]</code></pre><ul><li>A trait type <code>&lt;Trait&gt;Trait</code> will be automatically defined</li><li><code>&lt;Can&gt;</code> and <code>&lt;Cannot&gt;</code> are words that indicates whether a data type exhibits the trait.</li><li><code>&lt;Trait1&gt;</code>, <code>&lt;Trait2&gt;</code>, etc. are used to define composite traits.</li></ul><p>The as-clause, prefix-clause, and with-clause are all optional.</p><h3 id="Specifying-super-type-for-trait-1"><a class="docs-heading-anchor" href="#Specifying-super-type-for-trait-1">Specifying super-type for trait</a><a class="docs-heading-anchor-permalink" href="#Specifying-super-type-for-trait-1" title="Permalink"></a></h3><p>The as-clause is used to specify the super-type of the trait type. If the clause is missing, the super-type is defaulted to <code>Any</code>. This may be useful when you want to group a set of traits under the same hierarchy.  For example:</p><pre><code class="language-julia">abstract type Ability end
@trait Fly as Ability
@trait Swim as Ability</code></pre><h3 id="Using-custom-prefixes-1"><a class="docs-heading-anchor" href="#Using-custom-prefixes-1">Using custom prefixes</a><a class="docs-heading-anchor-permalink" href="#Using-custom-prefixes-1" title="Permalink"></a></h3><p>When you define a trait using verbs like <em>Fly</em> or <em>Swim</em> in the above, it makes sense to define trait types with <code>Can</code> and <code>Cannot</code> prefixes.  But, what if you want to define a trait using a noun or an adjective? In that case, you can define your trait with the prefix-clause. For example:</p><pre><code class="language-julia">@trait Iterable prefix Is,Not</code></pre><p>In this case, the following types will be defined instead:</p><pre><code class="language-none">IsIterable
NotIterable</code></pre><p>This should make your code a lot more readable.</p><h3 id="Making-composite-traits-1"><a class="docs-heading-anchor" href="#Making-composite-traits-1">Making composite traits</a><a class="docs-heading-anchor-permalink" href="#Making-composite-traits-1" title="Permalink"></a></h3><p>Sometimes we really want to compose traits and use a single one directly for dispatch.  In that case, we can just use the with-clause like this:</p><pre><code class="language-julia">@trait FlySwim with CanFly,CanSwim</code></pre><p>This above syntax would define a new trait where it assumes the sub-traits <code>Fly</code> and <code>Swim</code>.  Then, we can just apply the Holy Trait pattern as usual:</p><pre><code class="language-julia">spank(x) = spank(flyswimtrait(x), x)
spank(::CanFlySwim, x) = &quot;Flying high and diving deep&quot;
spank(::CannotFlySwim, x) = &quot;Too Bad&quot;</code></pre><h2 id="Assigning-traits-to-types-1"><a class="docs-heading-anchor" href="#Assigning-traits-to-types-1">Assigning traits to types</a><a class="docs-heading-anchor-permalink" href="#Assigning-traits-to-types-1" title="Permalink"></a></h2><p>Once you define your favorite traits, you may assign any data type to any traits. The syntax of the assignment is as follows:</p><pre><code class="language-julia">@assign &lt;DataType&gt; with &lt;Trait1&gt;,&lt;Trait2&gt;,...</code></pre><p>You can assign a data type with 1 or more traits in a single statement:</p><pre><code class="language-julia">struct Crane end
@assign Crane with CanFly,CanSwim</code></pre><p>When you assign traits to a data type, it will be equivalent to defining these functions:</p><pre><code class="language-julia">flytrait(::Crane) = CanFly()
swimtrait(::Crane) = CanSwim()</code></pre><h2 id="Specifying-interfaces-1"><a class="docs-heading-anchor" href="#Specifying-interfaces-1">Specifying interfaces</a><a class="docs-heading-anchor-permalink" href="#Specifying-interfaces-1" title="Permalink"></a></h2><p>A useful feature of traits is to define formal interfaces.  Currently, Julia does not come with any facility to specify interface contracts.  The users are expected to look up interface definitions from documentations and make sure that they implement those contracts per documentation.</p><p>This package provides additional machinery for users to formally define interfaces. It also comes with a macro for verifying the validity of data type implementations.</p><h3 id="Formal-interface-contracts-1"><a class="docs-heading-anchor" href="#Formal-interface-contracts-1">Formal interface contracts</a><a class="docs-heading-anchor-permalink" href="#Formal-interface-contracts-1" title="Permalink"></a></h3><p>Once you have defined a trait, you may define a set of interface contracts that a data type must implement in order to carry that trait.  These contracts are registered in the BinaryTraits system using the <code>@implement</code> macro. The syntax of <code>@implement</code> is as follows:</p><pre><code class="language-julia">@implement &lt;CanType&gt; by &lt;FunctionSignature&gt;</code></pre><p>The value of <code>&lt;CanType&gt;</code> is the positive side of a trait e.g. <code>CanFly</code>, <code>IsIterable</code>, etc.  The <code>&lt;FunctionSignature&gt;</code> is basically a standard function signature.</p><p>The followings are all valid usages:</p><pre><code class="language-julia">@implement CanFly by liftoff(_)
@implement CanFly by fly(_, direction::Float64, altitude::Float64)
@implement CanFly by speed(_)::Float64</code></pre><p>The underscore <code>_</code> is a special syntax where you can indicate which positional argument you want to pass an object to the function.  The object is expected to have a type that is assigned to the Fly trait.</p><p>When return type is not specified, it is default to <code>Any</code>. Return type is currently not validated so it could be used here just for documentation purpose.</p><h3 id="Implementing-interface-contracts-1"><a class="docs-heading-anchor" href="#Implementing-interface-contracts-1">Implementing interface contracts</a><a class="docs-heading-anchor-permalink" href="#Implementing-interface-contracts-1" title="Permalink"></a></h3><p>A data type that is assigned to a trait should implement all interface contracts. From the previous section, we established three contracts for the <code>Fly</code> trait - <code>liftoff</code>, <code>fly</code>, and <code>speed</code>. To satisfy those contracts, we must implement those functions.</p><p>For example, let&#39;s say we are defining a <code>Bird</code> type that exhibits <code>Fly</code> trait, we can implement the following contracts:</p><pre><code class="language-julia">abstract type Animal end
struct Bird &lt;: Animal end
@assign Bird with CanFly

# implmementation of CanFly contracts
liftoff(bird::Bird) = &quot;Hoo hoo!&quot;
fly(bird::Bird, direction::Float64, altitude::Float64) = &quot;Getting there!&quot;
speed(bird::Bird) = 10.0</code></pre><p>Here, we implement the contracts directly with the specific concrete type. What if you have multiple types that satisfy the same trait. Holy Trait comes to rescue:</p><pre><code class="language-julia">liftoff(x::Animal) = liftoff(flytrait(x), x)
liftoff(::CanFly, x) = &quot;Hi ho!&quot;
liftoff(::CannotFly, x) = &quot;Hi ho!&quot;</code></pre><h3 id="Validating-a-type-against-its-interfaces-1"><a class="docs-heading-anchor" href="#Validating-a-type-against-its-interfaces-1">Validating a type against its interfaces</a><a class="docs-heading-anchor-permalink" href="#Validating-a-type-against-its-interfaces-1" title="Permalink"></a></h3><p>The reason for spending so much effort in specifying interface contracts is so that we have a high confidence about our code.  Julia is a dynamic system and so generally speaking we do not have any static type checking in place. BinaryTraits now gives you that capability.</p><p>The <code>@check</code> macro can be used to verify whether your data type has fully implemented its assigned traits and respective interface contracts.  The usage is embarrassingly simple.  You can just call the <code>@check</code> macro with the data type:</p><pre><code class="language-julia">julia&gt; @check(Bird)
✅ Bird has no interface contract requirements.</code></pre><p>The <code>@check</code> macro returns an <code>InterfaceReview</code> object, which gives you the validation result.  The warnings are generated so that it comes up in the log file. The string representation of the <code>InterfaceReview</code> object is designed to clearly show you what has been implemented and what&#39;s not.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>When you define composite traits, all contracts from the underlying traits must be implemented as well.  If you have a <code>FlySwim</code> trait, then all contracts specified for <code>CanFly</code> and <code>CanSwim</code> are required even though you have not added any new contracts for <code>CanFlySwim</code>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>One way to utilize the <code>@check</code> macro is to put that in your module&#39;s <code>__init__</code> function so that it is verified before the package is used.  Another option is to do that in your test suite and so it will be run every single time.</p></div></div><h2 id="Additional-step-for-framework-providers-1"><a class="docs-heading-anchor" href="#Additional-step-for-framework-providers-1">Additional step for framework providers</a><a class="docs-heading-anchor-permalink" href="#Additional-step-for-framework-providers-1" title="Permalink"></a></h2><p>BinaryTraits is designed to allow one module to define traits and interfaces and have other modules implementing them.  For example, it should be possible for <a href="https://github.com/JuliaData/Tables.jl">Tables.jl</a> to define traits for row tables and column tables and required interface functions, and have all of its <a href="https://github.com/JuliaData/Tables.jl/blob/master/INTEGRATIONS.md">integrations</a> participate in the same traits system.</p><p>In order to facilitate interaction between modules, BinaryTraits requires the framework provider (e.g. Tables.jl in the example above) to add the following code in its <code>__init__</code> function:</p><pre><code class="language-julia">function __init__()
    inittraits(@__MODULE__)
end</code></pre><p>This additional steps allows all packages that utilize BinaryTraits to register their traits and interface contracts at a central location.</p><h2 id="Summary-1"><a class="docs-heading-anchor" href="#Summary-1">Summary</a><a class="docs-heading-anchor-permalink" href="#Summary-1" title="Permalink"></a></h2><p>The ability to design software with traits and interfaces and the ability to verify software for conformance to established interface contracts are highly desirable for professional software development projects.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Motivation</a><a class="docs-footer-nextpage" href="../concepts/">Concepts »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 5 May 2020 04:51">Tuesday 5 May 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
